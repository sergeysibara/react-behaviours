### Mixin alternative for React
####Created in 2015

#### Build creating
1. go to "library" folder
2. run webpack
3. go to "example" folder
4. run webpack

#### Run example
Open example/dist/index.html in browser

#### Description
###### Существующие подходы
Для расширения функционала компонентов с возможностью повторного использования этого функционала в других компонентах существует несколько подходов. Наиболее распространенные - 
это миксины, ES 7 Decorators, Higher Order Components (HOC).

Миксины имеют следующие недостатки:
- они расширяют исходный объект, увеличивая в нем количество методов и свойств;
- при добавление функционала к объекту из нескольких источников увеличивается вероятность того, что возникнет пересечение имен свойств или методов;
- нет возможности временно отключить добавленный функционал.

Один из способов заменить миксины — использовать декораторы классов из ES7. С помощью них так же можно подмешивать в класс какие-нибудь методы и свойства.
Но данный способ имеет те же недостатки, что и миксины.

Higher Order Components  
Лишен недостатков миксин, но требует другое мышление при разработке. Если миксины работают на одном уровне с компонентом, то HOC помещает компонент или другой HOC внутри себя.

##### Behaviours (поведения)
Основная идея в том, что каждый UI компонент может иметь какое-то поведение, которое может быть общим у нескольких разных UI компонентов.  
Вместо смешивания применяется композиция. Т.е. исходный объект хранит ссылки на другие объекты, в которых реализован нужный функционал.
В данном подходе поведение выносится в отдельный объект, который можно присоединить к любому react-компоненту. Таких объектов у одного компонента может быть несколько.  
Данный подход похож на миксины, но позволяет избавиться от их недостатков. Причем работа с объектами-поведениями схожа с работой миксин в реакт компонентах.  
В данном случае реакт компонент хранит массив ссылок на другие объекты (в данном контексте эти объекты называются поведениями - behaviour).
Функционал компонента расширяется за счет добавления к нему одного или нескольких поведений.
Если сравнивать с HOC, то HOC сделан на базе паттерна декоратор, а данный подход на базе паттерна комповщик.

##### Описание работы поведений
Когда в реакт компоненте вызывается один из lifecycle методов (componentWillMount, componentDidMount, componentWillUpdate, componentDidUpdate, componentWillUnmount), они вызываются и 
во всех активных объектах-поведениях. Как и при использовании миксин в реакт компонентах, сначала вызываются методы в поведениях, а потом в самом компоненте. 
Также аналогично вызываются некоторые стандартные обработчики событий, такие как onKeyDown, onChange и т.д.  
**Заметка:** при использовании componentWillReceiveProps(nextprops) в компонентах вызывается метод updateProps(currentBehaviourProps), в котором currentBehaviourProps - это props относящиеся только к нему.

Чтобы пользовательский компонент мог использовать поведения, он должен быть унаследован от класса BehavioursContainer, а также в его конструкторе должны быть добавлены сами поведения:  
this.behaviours = [new BehaviourA(props.BehaviourA, this), new BehaviourB(props.BehaviourB, this)];

Пользовательские поведения наследуются от класса Behaviour.
Данные в поведение передаются через родительский компонент через props с указанием имени поведения:  
```javascript
<ChildComponent  
    BehaviourA={{enabled: this.state.BehaviourA_enabled, prop1: value}}  
    BehaviourB={{enabled: true, prop1: this.state.BehaviourB_prop1}}  
/>  
```
Либо можно передать данные как обычно через props и устанавливать вручную их в самом компоненте: 
```javascript
this.behaviourA.enabled = false;
```

##### Описание примера
В примере в компонент MaskInput добавлены 2 объекта с поведением: первое разрешает вводить только цифры, а второе не дает ввести текст длинною более 5 символов. Компонент TunableInput содержит MaskInput и передает ему состояние чекбоксов.
На странице любое из этих поведений отключается/включается установкой флажка в соответствующем checkbox.

##### Преимущества предложенного подхода
- У каждого поведения своя область видимости, в отличие от миксин. Нет смешивания свойств и методов компонента с другими объектами, как в случае с миксинами.
- Позволяет в атрибутах (this.props) компонента задать свойства конкретным поведениям.
Т.е. props разделены по behaviours, в которых они используются, а не находятся в общей видимости react компонента.
Получается, что каждое поведение видит и работает только с данными, которые предназначены именно ему.
Данный способо не явялется обязательным для передачи данных в поведения.
- Т.к. есть доступ к компоненту, то любой объект-поведение может легко обратиться к другому объекту-поведению.  
- Возможность отключать поведение через props или в самом компоненте.

##### Все behaviours имеют следующие свойства
- enable - для отключения на случай, если в проекте есть похожие компоненты, которые отличаются только наличием конкретного поведения. 
Также позволяет в реальном времени включить/выключить поведение.
- owner - ссылка на react компонент, который содержит данный behaviour. 
- name - имя данного Behaviour.
